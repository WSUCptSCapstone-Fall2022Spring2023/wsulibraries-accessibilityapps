"use strict";
/**
 * Copyright 2022 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Realm = exports.RealmType = void 0;
const protocol_js_1 = require("../../../protocol/protocol.js");
const scriptEvaluator_js_1 = require("./scriptEvaluator.js");
const browsingContextStorage_js_1 = require("../context/browsingContextStorage.js");
var RealmType;
(function (RealmType) {
    RealmType["window"] = "window";
})(RealmType = exports.RealmType || (exports.RealmType = {}));
class Realm {
    static #realmMap = new Map();
    static create(realmId, browsingContextId, executionContextId, origin, type, sandbox, cdpSessionId, cdpClient) {
        const realm = new Realm(realmId, browsingContextId, executionContextId, origin, type, sandbox, cdpSessionId, cdpClient);
        Realm.#realmMap.set(realm.realmId, realm);
        return realm;
    }
    static findRealms(filter = {}) {
        return Array.from(Realm.#realmMap.values()).filter((realm) => {
            if (filter.realmId !== undefined && filter.realmId !== realm.realmId) {
                return false;
            }
            if (filter.browsingContextId !== undefined &&
                filter.browsingContextId !== realm.browsingContextId) {
                return false;
            }
            if (filter.executionContextId !== undefined &&
                filter.executionContextId !== realm.executionContextId) {
                return false;
            }
            if (filter.type !== undefined && filter.type !== realm.type) {
                return false;
            }
            if (filter.sandbox !== undefined && filter.sandbox !== realm.#sandbox) {
                return false;
            }
            if (filter.cdpSessionId !== undefined &&
                filter.cdpSessionId !== realm.#cdpSessionId) {
                return false;
            }
            return true;
        });
    }
    static findRealm(filter) {
        const maybeRealms = Realm.findRealms(filter);
        if (maybeRealms.length !== 1) {
            return undefined;
        }
        return maybeRealms[0];
    }
    static getRealm(filter) {
        const maybeRealm = Realm.findRealm(filter);
        if (maybeRealm === undefined) {
            throw new protocol_js_1.Message.NoSuchFrameException(`Realm ${JSON.stringify(filter)} not found`);
        }
        return maybeRealm;
    }
    static clearBrowsingContext(browsingContextId) {
        Realm.findRealms({ browsingContextId }).map((realm) => realm.delete());
    }
    delete() {
        Realm.#realmMap.delete(this.realmId);
        scriptEvaluator_js_1.ScriptEvaluator.realmDestroyed(this);
    }
    #realmId;
    #browsingContextId;
    #executionContextId;
    #origin;
    #type;
    #sandbox;
    #cdpSessionId;
    #cdpClient;
    constructor(realmId, browsingContextId, executionContextId, origin, type, sandbox, cdpSessionId, cdpClient) {
        this.#realmId = realmId;
        this.#browsingContextId = browsingContextId;
        this.#executionContextId = executionContextId;
        this.#sandbox = sandbox;
        this.#origin = origin;
        this.#type = type;
        this.#cdpSessionId = cdpSessionId;
        this.#cdpClient = cdpClient;
    }
    toBiDi() {
        return {
            realm: this.realmId,
            origin: this.origin,
            type: this.type,
            context: this.browsingContextId,
            ...(this.#sandbox !== undefined ? { sandbox: this.#sandbox } : {}),
        };
    }
    get realmId() {
        return this.#realmId;
    }
    get browsingContextId() {
        return this.#browsingContextId;
    }
    get executionContextId() {
        return this.#executionContextId;
    }
    get origin() {
        return this.#origin;
    }
    get type() {
        return this.#type;
    }
    get cdpClient() {
        return this.#cdpClient;
    }
    async callFunction(functionDeclaration, _this, _arguments, awaitPromise, resultOwnership) {
        const context = browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(this.browsingContextId);
        await context.awaitUnblocked();
        return {
            result: await scriptEvaluator_js_1.ScriptEvaluator.callFunction(this, functionDeclaration, _this, _arguments, awaitPromise, resultOwnership),
        };
    }
    async scriptEvaluate(expression, awaitPromise, resultOwnership) {
        const context = browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(this.browsingContextId);
        await context.awaitUnblocked();
        return {
            result: await scriptEvaluator_js_1.ScriptEvaluator.scriptEvaluate(this, expression, awaitPromise, resultOwnership),
        };
    }
    async disown(handle) {
        await scriptEvaluator_js_1.ScriptEvaluator.disown(this, handle);
    }
    /**
     * Serializes a given CDP object into BiDi, keeping references in the
     * target's `globalThis`.
     * @param cdpObject CDP remote object to be serialized.
     * @param resultOwnership indicates desired OwnershipModel.
     */
    async serializeCdpObject(cdpObject, resultOwnership) {
        return await scriptEvaluator_js_1.ScriptEvaluator.serializeCdpObject(cdpObject, resultOwnership, this);
    }
    /**
     * Gets the string representation of an object. This is equivalent to
     * calling toString() on the object value.
     * @param cdpObject CDP remote object representing an object.
     * @param realm
     * @returns string The stringified object.
     */
    async stringifyObject(cdpObject) {
        return scriptEvaluator_js_1.ScriptEvaluator.stringifyObject(cdpObject, this);
    }
}
exports.Realm = Realm;
//# sourceMappingURL=realm.js.map