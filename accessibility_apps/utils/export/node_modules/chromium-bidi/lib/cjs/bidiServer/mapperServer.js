"use strict";
/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapperServer = void 0;
const debug_1 = __importDefault(require("debug"));
const debugInternal = (0, debug_1.default)('bidiMapper:internal');
const debugLog = (0, debug_1.default)('bidiMapper:log');
const ws_1 = __importDefault(require("ws"));
const index_js_1 = require("../cdp/index.js");
class MapperServer {
    _cdpConnection;
    _mapperCdpClient;
    _handlers = new Array();
    static async create(cdpUrl, mapperContent) {
        const cdpConnection = await this._establishCdpConnection(cdpUrl);
        try {
            const mapperCdpClient = await this._initMapper(cdpConnection, mapperContent);
            return new MapperServer(cdpConnection, mapperCdpClient);
        }
        catch (e) {
            cdpConnection.close();
            throw e;
        }
    }
    constructor(_cdpConnection, _mapperCdpClient) {
        this._cdpConnection = _cdpConnection;
        this._mapperCdpClient = _mapperCdpClient;
        this._mapperCdpClient.on('Runtime.bindingCalled', this._onBindingCalled);
        this._mapperCdpClient.on('Runtime.consoleAPICalled', this._onConsoleAPICalled);
    }
    setOnMessage(handler) {
        this._handlers.push(handler);
    }
    sendMessage(messageJson) {
        return this._sendBidiMessage(messageJson);
    }
    close() {
        this._cdpConnection.close();
    }
    static async _establishCdpConnection(cdpUrl) {
        return new Promise((resolve, reject) => {
            debugInternal('Establishing session with cdpUrl: ', cdpUrl);
            const ws = new ws_1.default(cdpUrl);
            ws.once('error', reject);
            ws.on('open', () => {
                debugInternal('Session established.');
                const transport = new index_js_1.WebSocketTransport(ws);
                const connection = new index_js_1.CdpConnection(transport);
                resolve(connection);
            });
        });
    }
    async _sendBidiMessage(bidiMessageJson) {
        await this._mapperCdpClient.sendCommand('Runtime.evaluate', {
            expression: 'onBidiMessage(' + JSON.stringify(bidiMessageJson) + ')',
        });
    }
    _onBidiMessage(bidiMessage) {
        for (let handler of this._handlers)
            handler(bidiMessage);
    }
    _onBindingCalled = async (params) => {
        if (params.name === 'sendBidiResponse') {
            this._onBidiMessage(params.payload);
        }
    };
    _onConsoleAPICalled = async (params) => {
        debugLog('consoleAPICalled %s %O', params.type, params.args.map((arg) => arg.value));
    };
    static async _initMapper(cdpConnection, mapperContent) {
        debugInternal('Connection opened.');
        // await browserClient.Log.enable();
        const browserClient = cdpConnection.browserClient();
        const { targetId } = await browserClient.sendCommand('Target.createTarget', {
            url: 'about:blank',
        });
        const { sessionId: mapperSessionId } = await browserClient.sendCommand('Target.attachToTarget', { targetId, flatten: true });
        const mapperCdpClient = cdpConnection.getCdpClient(mapperSessionId);
        if (!mapperCdpClient) {
            throw new Error('Unable to connect to mapper CDP target');
        }
        await mapperCdpClient.sendCommand('Runtime.enable');
        await browserClient.sendCommand('Target.exposeDevToolsProtocol', {
            bindingName: 'cdp',
            targetId,
        });
        await mapperCdpClient.sendCommand('Runtime.addBinding', {
            name: 'sendBidiResponse',
        });
        const launchedPromise = new Promise((resolve, reject) => {
            const onBindingCalled = ({ name, payload, }) => {
                // Needed to check when Mapper is launched on the frontend.
                if (name === 'sendBidiResponse') {
                    try {
                        const parsed = JSON.parse(payload);
                        if (parsed.launched) {
                            mapperCdpClient.off('Runtime.bindingCalled', onBindingCalled);
                            resolve();
                        }
                    }
                    catch (e) {
                        reject(new Error('Could not parse initial bidi response as JSON'));
                    }
                }
            };
            mapperCdpClient.on('Runtime.bindingCalled', onBindingCalled);
        });
        await mapperCdpClient.sendCommand('Runtime.evaluate', {
            expression: mapperContent,
        });
        // Let Mapper know what is it's TargetId to filter out related targets.
        await mapperCdpClient.sendCommand('Runtime.evaluate', {
            expression: 'window.setSelfTargetId(' + JSON.stringify(targetId) + ')',
        });
        await launchedPromise;
        debugInternal('Launched!');
        return mapperCdpClient;
    }
}
exports.MapperServer = MapperServer;
//# sourceMappingURL=mapperServer.js.map