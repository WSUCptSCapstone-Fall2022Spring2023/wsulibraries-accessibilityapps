"use strict";
/**
 * Copyright 2021 Google LLC.
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowsingContextProcessor = void 0;
const log_js_1 = require("../../../utils/log.js");
const protocol_js_1 = require("../../../protocol/protocol.js");
const browsingContextImpl_js_1 = require("./browsingContextImpl.js");
const realm_js_1 = require("../script/realm.js");
const browsingContextStorage_js_1 = require("./browsingContextStorage.js");
const logContext = (0, log_js_1.log)(log_js_1.LogType.browsingContexts);
class BrowsingContextProcessor {
    sessions = new Set();
    #cdpConnection;
    #selfTargetId;
    #eventManager;
    constructor(cdpConnection, selfTargetId, eventManager) {
        this.#cdpConnection = cdpConnection;
        this.#selfTargetId = selfTargetId;
        this.#eventManager = eventManager;
        this.#setBrowserClientEventListeners(this.#cdpConnection.browserClient());
    }
    #setBrowserClientEventListeners(browserClient) {
        this.#setTargetEventListeners(browserClient);
    }
    #setTargetEventListeners(cdpClient) {
        cdpClient.on('Target.attachedToTarget', async (params) => {
            await this.#handleAttachedToTargetEvent(params, cdpClient);
        });
        cdpClient.on('Target.detachedFromTarget', async (params) => {
            await BrowsingContextProcessor.#handleDetachedFromTargetEvent(params);
        });
    }
    #setSessionEventListeners(sessionId) {
        if (this.sessions.has(sessionId)) {
            return;
        }
        this.sessions.add(sessionId);
        const sessionCdpClient = this.#cdpConnection.getCdpClient(sessionId);
        this.#setTargetEventListeners(sessionCdpClient);
        sessionCdpClient.on('*', async (method, params) => {
            await this.#eventManager.registerEvent({
                method: protocol_js_1.CDP.EventNames.EventReceivedEvent,
                params: {
                    cdpMethod: method,
                    cdpParams: params || {},
                    cdpSession: sessionId,
                },
            }, null);
        });
        sessionCdpClient.on('Page.frameAttached', async (params) => {
            await browsingContextImpl_js_1.BrowsingContextImpl.createFrameContext(params.frameId, params.parentFrameId, sessionCdpClient, sessionId, this.#eventManager);
        });
    }
    async #handleAttachedToTargetEvent(params, parentSessionCdpClient) {
        const { sessionId, targetInfo } = params;
        let targetSessionCdpClient = this.#cdpConnection.getCdpClient(sessionId);
        if (!this.#isValidTarget(targetInfo)) {
            // DevTools or some other not supported by BiDi target.
            await targetSessionCdpClient.sendCommand('Runtime.runIfWaitingForDebugger');
            await parentSessionCdpClient.sendCommand('Target.detachFromTarget', params);
            return;
        }
        logContext('AttachedToTarget event received: ' + JSON.stringify(params));
        this.#setSessionEventListeners(sessionId);
        if (browsingContextStorage_js_1.BrowsingContextStorage.hasKnownContext(targetInfo.targetId)) {
            // OOPiF.
            browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(targetInfo.targetId).convertFrameToTargetContext(targetSessionCdpClient, sessionId);
        }
        else {
            await browsingContextImpl_js_1.BrowsingContextImpl.createTargetContext(targetInfo.targetId, null, targetSessionCdpClient, sessionId, params.targetInfo.browserContextId ?? null, this.#eventManager);
        }
    }
    // { "method": "Target.detachedFromTarget",
    //   "params": {
    //     "sessionId": "7EFBFB2A4942A8989B3EADC561BC46E9",
    //     "targetId": "19416886405CBA4E03DBB59FA67FF4E8" } }
    static async #handleDetachedFromTargetEvent(params) {
        // TODO: params.targetId is deprecated. Update this class to track using
        // params.sessionId instead.
        // https://github.com/GoogleChromeLabs/chromium-bidi/issues/60
        const contextId = params.targetId;
        await browsingContextStorage_js_1.BrowsingContextStorage.findContext(contextId)?.delete();
    }
    async process_browsingContext_getTree(params) {
        const resultContexts = params.root === undefined
            ? browsingContextStorage_js_1.BrowsingContextStorage.getTopLevelContexts()
            : [browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(params.root)];
        return {
            result: {
                contexts: resultContexts.map((c) => c.serializeToBidiValue(params.maxDepth ?? Number.MAX_VALUE)),
            },
        };
    }
    async process_browsingContext_create(params) {
        const browserCdpClient = this.#cdpConnection.browserClient();
        let referenceContext = undefined;
        if (params.referenceContext !== undefined) {
            referenceContext = browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(params.referenceContext);
            if (referenceContext.parentId !== null) {
                throw new protocol_js_1.Message.InvalidArgumentException(`referenceContext should be a top-level context`);
            }
        }
        const result = await browserCdpClient.sendCommand('Target.createTarget', {
            url: 'about:blank',
            newWindow: params.type === 'window',
            ...(referenceContext?.cdpBrowserContextId
                ? { browserContextId: referenceContext.cdpBrowserContextId }
                : {}),
        });
        // Wait for the new tab to be loaded to avoid race conditions in the
        // `browsingContext` events, when the `browsingContext.domContentLoaded` and
        // `browsingContext.load` events from the initial `about:blank` navigation
        // are emitted after the next navigation is started.
        // Details: https://github.com/web-platform-tests/wpt/issues/35846
        const contextId = result.targetId;
        const context = browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(contextId);
        await context.awaitLoaded();
        return {
            result: context.serializeToBidiValue(1),
        };
    }
    async process_browsingContext_navigate(params) {
        const context = browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(params.context);
        return await context.navigate(params.url, params.wait !== undefined ? params.wait : 'none');
    }
    static async #getRealm(target) {
        if ('realm' in target) {
            return realm_js_1.Realm.getRealm({ realmId: target.realm });
        }
        const context = browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(target.context);
        return await context.getOrCreateSandbox(target.sandbox);
    }
    async process_script_evaluate(params) {
        const realm = await BrowsingContextProcessor.#getRealm(params.target);
        return await realm.scriptEvaluate(params.expression, params.awaitPromise, params.resultOwnership ?? 'none');
    }
    process_script_getRealms(params) {
        if (params.context !== undefined) {
            // Make sure the context is known.
            browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(params.context);
        }
        const realms = realm_js_1.Realm.findRealms({
            browsingContextId: params.context,
            type: params.type,
        }).map((realm) => realm.toBiDi());
        return { result: { realms } };
    }
    async process_script_callFunction(params) {
        const realm = await BrowsingContextProcessor.#getRealm(params.target);
        return await realm.callFunction(params.functionDeclaration, params.this || {
            type: 'undefined',
        }, // `this` is `undefined` by default.
        params.arguments || [], // `arguments` is `[]` by default.
        params.awaitPromise, params.resultOwnership ?? 'none');
    }
    async process_script_disown(params) {
        const realm = await BrowsingContextProcessor.#getRealm(params.target);
        await Promise.all(params.handles.map(async (h) => await realm.disown(h)));
        return { result: {} };
    }
    async process_browsingContext_close(commandParams) {
        const browserCdpClient = this.#cdpConnection.browserClient();
        const context = browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(commandParams.context);
        if (context.parentId !== null) {
            throw new protocol_js_1.Message.InvalidArgumentException('Not a top-level browsing context cannot be closed.');
        }
        const detachedFromTargetPromise = new Promise(async (resolve) => {
            const onContextDestroyed = (eventParams) => {
                if (eventParams.targetId === commandParams.context) {
                    browserCdpClient.off('Target.detachedFromTarget', onContextDestroyed);
                    resolve();
                }
            };
            browserCdpClient.on('Target.detachedFromTarget', onContextDestroyed);
        });
        await this.#cdpConnection
            .browserClient()
            .sendCommand('Target.closeTarget', {
            targetId: commandParams.context,
        });
        // Sometimes CDP command finishes before `detachedFromTarget` event,
        // sometimes after. Wait for the CDP command to be finished, and then wait
        // for `detachedFromTarget` if it hasn't emitted.
        await detachedFromTargetPromise;
        return { result: {} };
    }
    #isValidTarget(target) {
        if (target.targetId === this.#selfTargetId) {
            return false;
        }
        return ['page', 'iframe'].includes(target.type);
    }
    async process_cdp_sendCommand(params) {
        const client = params.cdpSession
            ? this.#cdpConnection.getCdpClient(params.cdpSession)
            : this.#cdpConnection.browserClient();
        const sendCdpCommandResult = await client.sendCommand(params.cdpMethod, params.cdpParams);
        return {
            result: sendCdpCommandResult,
            cdpSession: params.cdpSession,
        };
    }
    async process_cdp_getSession(params) {
        const context = params.context;
        const sessionId = browsingContextStorage_js_1.BrowsingContextStorage.getKnownContext(context).cdpSessionId;
        if (sessionId === undefined) {
            return { result: { cdpSession: null } };
        }
        return { result: { cdpSession: sessionId } };
    }
}
exports.BrowsingContextProcessor = BrowsingContextProcessor;
//# sourceMappingURL=browsingContextProcessor.js.map